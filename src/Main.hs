{-# LANGUAGE DuplicateRecordFields     #-}
{-# LANGUAGE FlexibleContexts          #-}
{-# LANGUAGE FlexibleInstances         #-}
{-# LANGUAGE GADTs                     #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE OverloadedStrings         #-}
{-# LANGUAGE RecordWildCards           #-}
{-# LANGUAGE ScopedTypeVariables       #-}
{-# LANGUAGE TypeApplications          #-}
{-# LANGUAGE TypeFamilies              #-}
{-# LANGUAGE TypeOperators             #-}
{-# LANGUAGE UndecidableInstances      #-}
{-# LANGUAGE DataKinds                 #-}

-- TODO: Body Rotation Options?
-- TODO: Filter Out Non-Moving People?
-- TODO: Print time
-- TODO: It currently crashes when it ends. We should stop the animation (or
--       loop it) when we run out of time.
-- TODO: If we're going for POAM we need to have a bunch of configurations that
--       let us design a particular item and then emit a file of the right type.
--
--       Basically, we need to cut off the thing. Then it works.
-- TODO: Visible body-part count filter
-- TODO: Move from arrays to vectors

module Main where


import           Data
import           Animation
import           Gif
import           Image
import           Smoothing
import           DanceView
import           Data.Generics.Record
import           Options.Generic
import           Data.Maybe
import           Data.Aeson
import           System.FilePath.Find   hiding (directory)
import           Data.String.Conv       (toS)
import qualified Data.ByteString        as B
import qualified Data.ByteString.Lazy   as LB


main :: IO ()
main = do
    opts :: Options <- unwrapRecord "DanceView - Watch the poses generated by pose networks."

    rawFrames <- getFrames opts

    let startMin     = fromMaybe 0 (start opts)
        endMin       = fromMaybe durationMins (end opts)
        durationMins = fromIntegral (length rawFrames) / (fps opts * 60)

        skipFrames = round $ startMin * 60 * fps opts
        takeFrames = round $ (endMin - startMin) * 60 * fps opts
        frames'    = (take takeFrames  . drop skipFrames) rawFrames
        
        -- Note: Pattern-match failure if there is not at least 1 frame
    let (frame1:remainingFrames) = frames'

        matchedFrames :: [Frame Person]
        matchedFrames = map snd $ scanl f (1, frame1) remainingFrames
            where
                f :: (Int, Frame Person) -> Frame Person -> (Int, Frame Person)
                f (counter, prevFrame) curFrame = (counter', newFrame)
                    where
                        counter'  = counter + length (getField @"people" curFrame)

                        newPeople :: [Person]
                        newPeople = zipWith rename matches names

                        rename (p1, Nothing, _) name = setField @"name" (show name) p1
                        rename (p1, Just p2, _) _    = setField @"name" (getField @"name" p2) p1

                        names     = [counter ..]
                        matches   = matchings (getField @"people" curFrame)
                                              (getField @"people" prevFrame)

                        -- Update the people in this frame
                        newFrame :: Frame Person
                        newFrame = setField @"people" newPeople curFrame

        finalFrames@(frame1':remainingFrames') = matchedFrames
        -- TODO: Smoothing doesn't work perfectly because tracking doesn't work
        --       perfectly. 
        -- finalFrames = scanl forwardFill frame1' remainingFrames'

    let frames = 
            case filterOpt opts of 
              Nothing                 -> finalFrames
              Just OnlySolo           -> filter onePerson finalFrames
              Just TakeLargest        -> map takeLargest finalFrames
              Just (AtLeastKJoints k) -> map (atLeastKJoints k) finalFrames

    case opts of
      DoAnimation {..} -> doAnimation frames opts
      DoImage     {..} -> doImage     frames opts
      DoGif       {..} -> doGif       frames opts
      JsonExport  {..} -> jsonExport  frames opts


doImage :: [Frame Person] -> Options -> IO ()
doImage frames opts =
    case style opts of
      Montage -> doMontage frames opts
      Fractal -> doFractal frames opts   


getFrames :: Options -> IO [Frame Person]
getFrames opts = go (sourceDirectory opts) (sourceJson opts)
    where
        go Nothing    Nothing     = error "Need to specify a source"
        go (Just dir) _           = fromScratch dir
        go _          (Just file) = fmap munge (readJson file)

        munge :: [Frame Skeleton2D] -> [Frame Person]
        munge = map f
            where
                f fsk = Frame (map fromSkeleton (getField @"people" fsk)) 
                              (getField @"frameNumber" fsk)

        -- | Load from a bunch of JSON files without additional data
        fromScratch dir = do
            jsonFiles  <- find (depth ==? 0) (extension ==? ".json") dir

            frameDatas :: [FrameData PersonData] <- mapM readJson jsonFiles

            let fds :: [FrameData Person]
                fds  = map g frameDatas
                g fd = FrameData (zipWith ((. (Person [] . show)) . smash) (getField @"people" fd) [(1 :: Integer)..])
                
                -- | Munge them into frames with frame numbers.
                frames' :: [Frame Person]
                frames' = zipWith (flip smash . Frame []) [1..] fds

            return frames'


readJson :: (FromJSON a) => FilePath -> IO a
readJson f = do
    -- Note: We strictly read here because otherwise we die from too many open
    -- files. There's probably a nicer way to do this, but hey.
    file <- B.readFile f

    return $ fromMaybe (error $ "Couldn't load data from file: " ++ show file)
                       (decode' (toS file)) 


-- | Writes what we know back to a convenient JSON format.
jsonExport :: [Frame Person] -> Options -> IO ()
jsonExport frames opts = do
    let skeletonFrames = map (\(Frame p s) -> Frame (map toSkeleton p) s) frames
    LB.writeFile (outFile opts) (encode skeletonFrames)

